import { __awaiter } from "tslib";
/* eslint-disable no-constant-condition */
import { CommonModule } from '@angular/common';
import { createConnection } from 'typeorm';
import { NgModule, APP_BOOTSTRAP_LISTENER, } from '@angular/core';
// @dynamic
export class AngularTypeormModule {
    /**
     * @param duration time in seconds
     * @description Pause for given amount of time
     */
    static wait(duration) {
        return new Promise((resolve, __) => {
            setTimeout(() => {
                resolve();
            }, duration * 1000);
        });
    }
    /**
     * @param configs  connection options
     * @description Initialize TypeOrm connection for root
     */
    static forRoot(configs) {
        return {
            ngModule: AngularTypeormModule,
            providers: [
                {
                    provide: APP_BOOTSTRAP_LISTENER,
                    useFactory: () => () => __awaiter(this, void 0, void 0, function* () {
                        let retryCount = 0;
                        while (true) {
                            try {
                                return yield createConnection(configs);
                            }
                            catch (err) {
                                retryCount += 1;
                                console.error(`TYPEORM CONNECTION ATTEMPT ${retryCount} FAILED: `, err);
                                yield this.wait(5);
                                continue;
                            }
                        }
                    }),
                    multi: true,
                },
            ],
        };
    }
}
AngularTypeormModule.decorators = [
    { type: NgModule, args: [{
                exports: [],
                providers: [],
                declarations: [],
                imports: [CommonModule],
            },] }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYW5ndWxhci10eXBlb3JtLm1vZHVsZS5qcyIsInNvdXJjZVJvb3QiOiJDOi9Vc2Vycy9hcnNsYS9Eb2N1bWVudHMvYW5ndWxhci10eXBlb3JtL3Byb2plY3RzL2FuZ3VsYXItdHlwZW9ybS9zcmMvIiwic291cmNlcyI6WyJsaWIvYW5ndWxhci10eXBlb3JtLm1vZHVsZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsMENBQTBDO0FBQzFDLE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUMvQyxPQUFPLEVBQXFCLGdCQUFnQixFQUFFLE1BQU0sU0FBUyxDQUFDO0FBQzlELE9BQU8sRUFDTCxRQUFRLEVBRVIsc0JBQXNCLEdBQ3ZCLE1BQU0sZUFBZSxDQUFDO0FBRXZCLFdBQVc7QUFPWCxNQUFNLE9BQU8sb0JBQW9CO0lBQy9COzs7T0FHRztJQUNLLE1BQU0sQ0FBQyxJQUFJLENBQUMsUUFBZ0I7UUFDbEMsT0FBTyxJQUFJLE9BQU8sQ0FBQyxDQUFDLE9BQU8sRUFBRSxFQUFFLEVBQUUsRUFBRTtZQUNqQyxVQUFVLENBQUMsR0FBRyxFQUFFO2dCQUNkLE9BQU8sRUFBRSxDQUFDO1lBQ1osQ0FBQyxFQUFFLFFBQVEsR0FBRyxJQUFJLENBQUMsQ0FBQztRQUN0QixDQUFDLENBQUMsQ0FBQztJQUNMLENBQUM7SUFFRDs7O09BR0c7SUFDSCxNQUFNLENBQUMsT0FBTyxDQUNaLE9BQTBCO1FBRTFCLE9BQU87WUFDTCxRQUFRLEVBQUUsb0JBQW9CO1lBQzlCLFNBQVMsRUFBRTtnQkFDVDtvQkFDRSxPQUFPLEVBQUUsc0JBQXNCO29CQUMvQixVQUFVLEVBQUUsR0FBRyxFQUFFLENBQUMsR0FBUyxFQUFFO3dCQUMzQixJQUFJLFVBQVUsR0FBRyxDQUFDLENBQUM7d0JBQ25CLE9BQU8sSUFBSSxFQUFFOzRCQUNYLElBQUk7Z0NBQ0YsT0FBTyxNQUFNLGdCQUFnQixDQUFDLE9BQU8sQ0FBQyxDQUFDOzZCQUN4Qzs0QkFBQyxPQUFPLEdBQUcsRUFBRTtnQ0FDWixVQUFVLElBQUksQ0FBQyxDQUFDO2dDQUNoQixPQUFPLENBQUMsS0FBSyxDQUNYLDhCQUE4QixVQUFVLFdBQVcsRUFDbkQsR0FBRyxDQUNKLENBQUM7Z0NBQ0YsTUFBTSxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO2dDQUNuQixTQUFTOzZCQUNWO3lCQUNGO29CQUNILENBQUMsQ0FBQTtvQkFDRCxLQUFLLEVBQUUsSUFBSTtpQkFDWjthQUNGO1NBQ0YsQ0FBQztJQUNKLENBQUM7OztZQW5ERixRQUFRLFNBQUM7Z0JBQ1IsT0FBTyxFQUFFLEVBQUU7Z0JBQ1gsU0FBUyxFQUFFLEVBQUU7Z0JBQ2IsWUFBWSxFQUFFLEVBQUU7Z0JBQ2hCLE9BQU8sRUFBRSxDQUFDLFlBQVksQ0FBQzthQUN4QiIsInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnN0YW50LWNvbmRpdGlvbiAqL1xyXG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xyXG5pbXBvcnQgeyBDb25uZWN0aW9uT3B0aW9ucywgY3JlYXRlQ29ubmVjdGlvbiB9IGZyb20gJ3R5cGVvcm0nO1xyXG5pbXBvcnQge1xyXG4gIE5nTW9kdWxlLFxyXG4gIE1vZHVsZVdpdGhQcm92aWRlcnMsXHJcbiAgQVBQX0JPT1RTVFJBUF9MSVNURU5FUixcclxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuXHJcbi8vIEBkeW5hbWljXHJcbkBOZ01vZHVsZSh7XHJcbiAgZXhwb3J0czogW10sXHJcbiAgcHJvdmlkZXJzOiBbXSxcclxuICBkZWNsYXJhdGlvbnM6IFtdLFxyXG4gIGltcG9ydHM6IFtDb21tb25Nb2R1bGVdLFxyXG59KVxyXG5leHBvcnQgY2xhc3MgQW5ndWxhclR5cGVvcm1Nb2R1bGUge1xyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSBkdXJhdGlvbiB0aW1lIGluIHNlY29uZHNcclxuICAgKiBAZGVzY3JpcHRpb24gUGF1c2UgZm9yIGdpdmVuIGFtb3VudCBvZiB0aW1lXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBzdGF0aWMgd2FpdChkdXJhdGlvbjogbnVtYmVyKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIF9fKSA9PiB7XHJcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgfSwgZHVyYXRpb24gKiAxMDAwKTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIGNvbmZpZ3MgIGNvbm5lY3Rpb24gb3B0aW9uc1xyXG4gICAqIEBkZXNjcmlwdGlvbiBJbml0aWFsaXplIFR5cGVPcm0gY29ubmVjdGlvbiBmb3Igcm9vdFxyXG4gICAqL1xyXG4gIHN0YXRpYyBmb3JSb290KFxyXG4gICAgY29uZmlnczogQ29ubmVjdGlvbk9wdGlvbnNcclxuICApOiBNb2R1bGVXaXRoUHJvdmlkZXJzPEFuZ3VsYXJUeXBlb3JtTW9kdWxlPiB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBuZ01vZHVsZTogQW5ndWxhclR5cGVvcm1Nb2R1bGUsXHJcbiAgICAgIHByb3ZpZGVyczogW1xyXG4gICAgICAgIHtcclxuICAgICAgICAgIHByb3ZpZGU6IEFQUF9CT09UU1RSQVBfTElTVEVORVIsXHJcbiAgICAgICAgICB1c2VGYWN0b3J5OiAoKSA9PiBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIGxldCByZXRyeUNvdW50ID0gMDtcclxuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGNyZWF0ZUNvbm5lY3Rpb24oY29uZmlncyk7XHJcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICByZXRyeUNvdW50ICs9IDE7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxyXG4gICAgICAgICAgICAgICAgICBgVFlQRU9STSBDT05ORUNUSU9OIEFUVEVNUFQgJHtyZXRyeUNvdW50fSBGQUlMRUQ6IGAsXHJcbiAgICAgICAgICAgICAgICAgIGVyclxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMud2FpdCg1KTtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIG11bHRpOiB0cnVlLFxyXG4gICAgICAgIH0sXHJcbiAgICAgIF0sXHJcbiAgICB9O1xyXG4gIH1cclxufVxyXG4iXX0=